---
layout:    post
title:     常用JavaScript
category:  JavaScript
tags:      JavaScript
keyword:   JavaScript
description:  常用JavaScript
---

<div class="post-con">
<h4>1. 判断一个值是否是数字</h4>
<pre><code class="javascript">
var isNumber = function isNumber(value) {
	return typeof value === 'number' && isFinite(value);
}
// isFinite 可以筛选掉NaN和infinity，但isFinite 会试图把它的运算数转换为一个数字。
</code></pre>

<h4>2. typeof 不能辨别数组和对象</h4>
<pre><code class="javascript">
if (my_value && typeof my_value === 'object' && my_value.constructor === Array){
	// my_value 是一个数组
}
// 上面的检测对于不同帧或窗口创建的数组将会给出false。当数组有可能在其他的帧中被创建，下面的检测更加可靠
function isArray(v){
    return Object.prototype.toString.apply(v) === '[object Array]';
} 

function isObject(v){
    return Object.prototype.toString.apply(v)===  '[object Object]';
} 
</code></pre>

<h4>3. contains方法：判断一个字符窜是否包含另外一个字符窜</h4>
<pre><code class="javascript">
function contains(target, str, separator){
	return separator ?
		   (separator + target + separator).indexOf(separator + str + separator) > -1 :
		   target.indexOf(str) > -1;
}
</code></pre>

<h4>4. startsWith方法：判断目标字符窜是否位于原字符窜的开始之处。可以说是contains方法的变种</h4>
<pre><code class="javascript">
// 最后一个参数是忽略大小写
function startsWith(target, str, ignorecase) {
	var start_str = target.substr(0, str.length);
	return ignorecase ? start_str.toLowerCase() === str.toLowerCase() :
	                    start_str === str;
}
</code></pre>

<h4>5. endsWith方法：与startsWith相反</h4>
<pre><code class="javascript">
function endsWith(target, str, ignorecase){
	var end_str = target.substring(target.length - str.length);
	return ignorecase ? end_str.toLowerCase() === str.tolowerCase() :
	                    end_str === str;
}
</code></pre>

<h4>6. repeat方法：将一个字符窜重复自身N次</h4>
<pre><code class="javascript">
// 版本1：利用空数组的join方法
function repeat(target, n) {
	return (new Array(n + 1)).join(target);
}

// 版本2：版本1的改良版，创建一个对象，拥有length属性，然后利用call方法去调用数组原型的join方法，省去创建数组这一步，性能大为提高。重复次数越多，两者对比越明显。
// ps：之所以要创建一个length属性的对象，是因为要调用数组的原型方法，需要指定call的第一个参数为类数组对象。而类数组对象的必要条件是其length属性值为非负整数。
function repeat(target, n) {
	return Array.prototype.join.call({
		length: n + 1
	}, target);
}

// 版本3：版本2的改良版，利用闭包将类数组对象与数组原型的join方法缓存起来，省得每次都要重复创建与寻找方法。
var repeat = (function() {
	var join = Arrar.prototype.join, obj = {};
	return function(target, n) {
		obj.length = n + 1;
		return join.call(obj, target);
	}
})();

// 版本4：从算法上着手，使用二分法，比如我们将ruby重复5次，其实我们第二次已得到rubyruby，那么第3次直接用rubyruby进行操作，而不是用ruby
function repeat(target, n) {
	var s = target, total = [];
	while (n > 0) {
		if(n % 2 == 1)
			total[total.length] = s; // 如果是奇数
		if(n == 1)
			break;
		s += s;
		n = n >> 1;// 相当于将n除以2取其商，或说开2二次方
	}
	return total.join('');
}

// 版本5：版本4的变种，免去创建数组与使用join方法。它的悲剧之处在于它在循环中创建的字符窜比要求的还长，需要回减一下。
function repeat(target, n) {
	var s = target, c = s.length * n;
	do {
		s += s;
	} while (n = n >> 1);
	s = s.substring(0, c);
	return s;
}

// 版本6：版本4的改良版。
function repeat(target, n) {
	var s = target, total = "";
	while(n > 0) {
		if(n % 2 == 1)
			total += s;
		if(n == 1)
			break;
		s += s;
		n = n >> 1;
	}
	return total;
}

// 版本7：与版本6相近，不过递归在浏览器下好像都做了优化（包括IE6），与其他版本相比，属于上乘方案之一。
function repeat(target, n) {
	if (n == 1) {
		return target;
	}
	var s = repeat(target, Math.floor(n / 2));
	s += s;
	if(n % 2) {
		s += target;
	}
	return s;
}

// 版本8：反例，很慢，不过实际上它还是可行的，除非将n设成上百成千。
function repeat(target, n) {
	return (n <= 0) ? "" : target.concat(repeat(target, --n));
}

// ps: 经测试，版本6在各个浏览器的得分是最高的。
</code></pre>

<h4>7. byteLen方法：取得一个字符串所有字节的长度。</h4>
<p>这是一个后端过来的方法，如果将一个英文字符插入数据库 char、varchar、text 类型的字段时占用一个字节，而一个中文字符插入时占用两个字节，为了避免插入溢出，就需要在客户端判断字符串的长度。</p>
<pre><code class="javascript">
// 版本1：假设字符串的每个字符的Unicode 编码均 <= 255，byteLength 为字符串长度；
// 再遍历字符串，遇到 Unicode 编码 > 255 时，为byteLength 补加1。
function byteLen(target) {
	var byteLength = target.length, i = 0;
	for(; i < target.length, i++) {
		if (target.charCodeAt(i) > 255) {
			byteLength++;
		}
	}
	return byteLength;
}

// 版本2：使用正则，并支持制定汉字的存储字节数。比如mysql存储汉字时，是用3个字节数的。
function byteLen(target, fix) {
	var fix = fix ? fix : 2,
		str = new Array(fix + 1).join("-");
	return target.replace(/[^\x00-\xff]/g, str).length;

}

// 版本3：来自腾讯的解决方案。腾讯通过多子域名 + postMessage + manifest 离线 proxy 页面的方式扩大localStorage的存储空间，在这过程中需要知道用户已经存了多少东西，因此，我们就必须编写一个严谨的byteLen方法。
/**
 * http://www.alloyteam.com/2013/12/js-calculate-the-number-of-bytes-occupied-by-a-string/
 * 计算字符串所占的内存字节数，默认使用UTF-8的编码方式计算，也可制定为UTF-16
 * UTF-8 是一种可变长度的 Unicode 编码格式，使用一至四个字节为每个字符编码
 * 
 * 000000 - 00007F(128个代码)      0zzzzzzz(00-7F)                             一个字节
 * 000080 - 0007FF(1920个代码)     110yyyyy(C0-DF) 10zzzzzz(80-BF)             两个字节
 * 000800 - 00D7FF 
   00E000 - 00FFFF(61440个代码)    1110xxxx(E0-EF) 10yyyyyy 10zzzzzz           三个字节
 * 010000 - 10FFFF(1048576个代码)  11110www(F0-F7) 10xxxxxx 10yyyyyy 10zzzzzz  四个字节
 * 
 * 注: Unicode在范围 D800-DFFF 中不存在任何字符
 * {@link <a onclick="javascript:pageTracker._trackPageview('/outgoing/zh.wikipedia.org/wiki/UTF-8');" href="http://zh.wikipedia.org/wiki/UTF-8">http://zh.wikipedia.org/wiki/UTF-8</a>}
 * 
 * UTF-16 大部分使用两个字节编码，编码超出 65535 的使用四个字节
 * 000000 - 00FFFF  两个字节
 * 010000 - 10FFFF  四个字节
 * 
 * {@link <a onclick="javascript:pageTracker._trackPageview('/outgoing/zh.wikipedia.org/wiki/UTF-16');" href="http://zh.wikipedia.org/wiki/UTF-16">http://zh.wikipedia.org/wiki/UTF-16</a>}
 * @param  {String} str 
 * @param  {String} charset utf-8, utf-16
 * @return {Number}
 * 为了计算速度，把两个for循环分开写了。
 */
function byteLen(str, charset) {
	var total = 0,
		charCode,
		i,
		len;
	charset = charset ? charset.toLowerCase() : '';
	if(charset === 'utf-16' || charset === 'utf16') {
		for (i = 0, len = str.length; i < len; i++) {
			charCode = str.charCodeAt(i);
			if(charCode <= 0xffff){
				total += 2;
			}else {
				total += 4;
			}
		}
	}else {
		for (i = 0, len = str.length; i < len; i++) {
			charCode = str.charCodeAt(i);
			if(charCode <= 0x007f) {
				total += 1;
			}else if (charCode <= 0x07ff) {
				total += 2;
			}else if (charCode <= 0xffff) {
				total += 3;
			}else {
				total += 4;
			}
		}
	}
	return total;
}
</code></pre>

<h4>8. truncate 方法：用于对字符串进行截断处理，当超过限定长度，默认添加三个点号或其他。</h4>
<pre><code class="javascript">
function truncate(target, length, truncation) {
	var length = length || 30;
	truncation = truncation === void(0) ? '...' : truncation;
	return target.length > length ? 
		   target.slice(0, length - truncation.length) + truncation :
		   String(target);
}
</code></pre>

<h4>9. camelize 方法：转换为驼峰风格。</h4>
<pre><code class="javascript">
function camelize(target) {
	if (target.indexOf('-') < 0 && target.indexOf('_') < 0) {
		return target; // 提前判断，提高getStyle等的效率
	}
	return target.replace(/[-_][^-_]/g, function(match) {
		return match.charAt(1).toUpperCase();
	});
}
</code></pre>

<h4>10. underscored方法：转化为下划线风格。</h4>
<pre><code class="javascript">
function underscored(target) {
	return target.replace(/([a-z\d])([A-Z])/g, '$1_$2').
		   replace(/\-/g, '_').toLowerCase();
}

// dasherize方法：转化为连字符风格，亦即CSS变量的风格。
function dasherize(target){
	underscored(target).replace(/_/g, '-');
}
</code></pre>

<h4>11. capitalize方法：首字母大小写</h4>
<pre><code class="javascript">
function capitalize(target) {
	return target.charAt(0).toUpperCase() + target.substring(1).toLowerCase();
}
</code></pre>

<h4>12. stripTags 方法：移除字符串中的html标签。</h4>
<p>但这方法有缺陷，如里面有script标签，会把这些不该显示出来的。在Prototype.js 中，它与strip、stripScripts是一组方法。</p>
<pre><code class="javascript">
function stripTags(target) {
	return String(target || "").replace(/<[^>]+>/g, '');
}
</code></pre>

<h4>13. stripScripts 方法：移除字符串中所有 script 标签</h4>
<pre><code class="javascript">
// 弥补stripTags 方法的缺陷，此方法应在stripTags之前调用。
function stripScripts(target) {
	return String(target || '').replace(/<script[^>]*>([\S\s]*?)<\/script>/img, '');
}
</code></pre>

<h4>14. escapeHTML 方法：将字符串经过html转义得到适合在页面中显示的内容，如将&lt; 替换成&amp;lt;。</h4>
<pre><code class="javascript">
function ecapeHTML(target) {
	return target.replace(/&/g, '&amp;')
		   .replace(/</g, '&lt;')
		   .replace(/>/g, '&gt;')
		   .replace(/"/g, '&quot;')
		   .replace(/'/g, '&#39;');
}
</code></pre>

<h4>15. unescapeHTML 方法</h4>
<pre><code class="javascript">
function unecapeHTML(target) {
	return target.replace(/&amp;/g, '&')
		   .replace(/&lt;/g, '<')
		   .replace(/&gt;/g, '>')
		   .replace(/&quot;/g, '"')
		   .replace(/&#39;/g, "'"); // ie下不支持&apos;(单引号)转义
}
</code></pre>

<h4>16. escapeRegExp 方法：将字符串安全格式化为正则表达式的源码。</h4>
function escapeRegExt(target) {
	return target.replace(/([-.*+?^${}()|[\]\/\\])/g, '\\$1');
}

<h4>17. pad方法：与trim相反，pad可以为字符串的某一端添加字符串。</h4>
<pre><code class="javascript">
// 常见的如日历在月份前补零，因此也被称之为 fillZero。
// 版本1：数组法，创建数组来放置填充物，然后在右边起截取。
function pad (target, n) {
	var zero = new Array(n).join('0'),
		str  = zero + target,
		result = str.substr(-n);
	return result;
}

// 版本2：版本1的变种
function pad (target, n) {
	return Array((n + 1) - target.toString().split('').length).join('0') + target;
}

// 版本3：二进制法。前半部分是创建一个含有n个零的大数，如(1<<5).toString(2),生成100000，然后再截短。
function pad (target, n) {
	return ((1 << n).toString(2) + target).slice(-n);
}

// 版本4：Math.pow法，思路同版本3。
function pad (target, n) {
	return (Math.pow(10, n) + "" + target).slice(-n);
}

// 版本5：toFixed法，思路与版本3差不多
function pad (target, n) {
	return (0..toFixed(n) + target).slice(-n);
}

// 版本6：创建一个超大数，在常规情况下是截不完的。
function pad (target, n) {
	return (1e20 + "" + target).slice(-n);
}

// 版本7：质朴长存法，就是先求得长度，然后一个个往左边补零，加到长度为n为止。
function pad (target, n) {
	var len = target.toString().length;
	while (len < n) {
		target = '0' + target;
		len += 1;
	}
	return target;
}

// 版本8：支持更多参数，允许从左或从右填充，以及使用什么内容进行填充。
function pad(target, n, filling, right, radix) {
	var num = target.toString(radix || 10),
		filling = filling || "0";
	while (num.length < n) {
		if(!right) {
			num = filling + num;
		}else {
			num += filling;
		}
	}
	return num;
}
</code></pre>
</div>