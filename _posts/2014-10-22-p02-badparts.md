---
layout:    default
title:     JavaScript语言精粹笔记之糟粕
category:  JavaScript
tags:      JavaScript语言精粹
keyword:   JavaScript语言精粹,JavaScript学习
description:  JavaScript语言精粹笔记 —— 糟粕。
---

<div class="post-con">
<h2>JavaScript 中存在一些有问题的特性，但我们很容易就能避免它们。</h2>

<h4>一、==</h4>
<p>JavaScript有两组相等运算符： === 和 !==，== 和 !=。</p>
<pre><code class="javascript">
// == 只有在两个运算数类型一致且拥有相同的值才会做出正确判断
// 如果两个运算数类型不同，会试图强制转换值的类型
'' == '0'           // false
0 == ''             // true
0 == '0'            // true

false == 'false'    // false
false == '0'        // true

false == undefined  // false
false == null       // false 
null == undefined   // true

' \t\r\n ' == 0     // true  
// 以上比较使用  ==== 运算符，结果都是false
// 传递性是一种编程约定。可以这么理解：对于任意的引用值 x、y和z，如果 x == y 和 y == z为true，那么 x == z 为true。
// 而JavaScript中的 == 运算符在某些特例上违背了传递性
</code></pre>

<h4>二、with语句(with Statement)</h4>
<pre><code class="javascript">
with (obj){
	a = b;
}
// 与下面的代码等同
if (obj.a === undefined){
	a = obj.b === undefined ? b : obj.b;
} else {
	obj.a = obj.b === undefined ?b : obj.b;
}
</code></pre>
<p>with 语句在这门语言存在，本身就严重影响了JavaScript处理器的速度，因为它阻断变量名的语法作用域绑定。</p>

<h4>三、eval</h4>
<p>eval 函数传递一个字符串给JavaScript 编译器，并且执行其结果。</p>
<pre><code class="javascript">
// 点表示法
eval("myValue = myObject." + myKey + ";");
// 下标表示法
myValue = myObject[myKey];
// 使用eval形式更加难以阅读。
</code></pre>
<p>eval 函数还会带来安全问题，因为它给被求值的文本授予了太多的权力。而且像with一样，降低了语言的性能。</p>
<p>
ps:<br/> 
1. Function 构造器是eval的另一种形式，应该避免使用它
2. 浏览器提供的 setTimeout 和setInterval 函数，它们能接字符串参数或函数参数。当传递的是字符串参数，setTimeout 和setInterval 会像eval那样去处理。应该避免使用字符串参数形式。
</p>

<h4>四、continue语句</h4>
<p>影响性能</p>

<h4>五、switch 穿越</h4>
<p>switch 语句的由来可以追溯到 FORTRAN IV 的go to语句。除非明确地中断流程(break),否则每次条件判断后都会穿越到下一个case条件。</p>

<h4>六、省略花括号</h4>
<p>if、while、do或for语句可以接受一个括在花括号中的代码块，也可以接受单行语句。</p>
<pre><code class="javascript">
if (ok)
	t = true;
	advance();
=> 
if (ok){
	t = true;
}
advance();
</code></pre>

<h4>七、++ --</h4>
<p>递增和递减运算符使得程序员可以用非常简洁的风格去编码。比如在C语言中，它们使得用一行代码实现字符串的复制成为可能：</p>
<pre><code class="c">
for (p = src, q = dest; *p; p++, q++ ) *q = *p;
</code></pre>
<p>事实上，这两个运算符鼓励了一种不够谨慎的编程风格。大多数的缓冲区溢出错误所造成的安全漏洞，都是由这样的编码导致的。</p>

<h4>八、位运算符</h4>
<p>JavaScript 有着与Java 相同的一套位运算符：</p>
<table>
	<tbody>
		<tr>
			<td>&</td>
			<td>and 按位与</td>
		</tr>
		<tr>
			<td>|</td>
			<td>or 按位或</td>
		</tr>
		<tr>
			<td>^</td>
			<td>xor 按位异或</td>
		</tr>
		<tr>
			<td>-</td>
			<td>not 按位非</td>
		</tr>
		<tr>
			<td>&gt;&gt;</td>
			<td>带符号的右位移</td>
		</tr>
		<tr>
			<td>&gt;&gt;&gt;</td>
			<td>无符号的（用0补足的）右位移</td>
		</tr>
		<tr>
			<td>&lt;&lt;</td>
			<td>左位移</td>
		</tr>
	</tbody>
</table>
<p>在Java里，位运算符处理的是整数。JavaScript没有整型，它只有双精度的浮点数。</p>
<p>因为，JavaScript位操作先把它们的数字运算数先转换成整数 &gt; 执行运算 &gt; 转换回去。</p>
<p>在多数语言中，这些位运算符接近于硬件处理，所以非常快。但JavaScript的执行环境一般接触不到硬件，所以非常慢。</p>

<h4>九、function语句对比function表达式</h4>
<pre><code class="javascript">
// function语句
function foo() {}
// function表达式
var foo = function foo() {}
</code></pre>
<p>function语句在解析时会发生被提升（被移动到定义时所在作用域的顶层）的情况。</p>

<h4>十、类型的包装对象</h4>
<p>JavaScript 有一套类型的包装对象。例如：</p>
<pre><code class="javascript">
new Boolean(false);
// 会返回一个对象，该对象有一个 valueOf 方法会返回被包装的值。其实这个完全没有必要。  
// 不要使用 new Boolean、new Number 或 new String
// 避免使用 new Object 和 new Array。可使用 {} 和 [] 来代替。
</code></pre>

<h4>十一、new</h4>
<p>JavaScript 的new运算符创建一个继承于其运算数的原型的新对象，然后调用该运算数，把新创建的对象绑定给this。</p>
<p>JavaScript是一门基于原型的语言，但它却拥有一个 new 操作符使得其看起来像一门经典的面向对象语言。同时也迷惑了程序员们，导致一些有问题的编程模式。</p>
<p>
1. 其实你永远不需要在JavaScript使用 new Object()。用字面量的形式{}去取代吧。<br>
2. 同理，不要使用 new Array() ，而代之以字面量[]<br>。JavaScript中的数组并不象Java中的数组那样工作的，使用类似Java的语法只会让你糊涂。
3. 同理不用使用 new Number, new String, 或者 new Boolean。这些的用法只会产生无用的类型封装对象。就直接使用简单的字面量吧。<br>
4. 不要使用 new Function 去创建函数对象。用函数表达式更好。比如：
</p>
<pre><code class="javascript">
frame[0].onfocus = new Function("document.bgColor = 'antiquewhite'");
// 更好的方式
frame[0].onfocus = function(){document.bgColor = 'antiquewhite'};
// 第二种形式让脚本编译器更快的看到函数主体，于是其中的语法错误也会更快被检测出来。
</code></pre>

<p>如果我们让用字符串做函数体，编译器不能看到它们。如果我们用字符串表达式做函数体，我们同样也看不到它们。</p>
<pre><code class="javascript">
selObj.onchange = new Function(”dynamicOptionListObjects[”+dol.index+”].change(this)”);
// 更好的方式就是不要盲目编程。通过制造一个返回值为函数的函数调用，我们可以明确的按值传递我们想要绑定的值。这允许我们在循环中初始化一系列 selObj 对象。
selObj.onchange = function(i){
	return function() {bynamicOptionListObjects[i].change(this);};
}(dol.index);

// 直接对一个函数使用new永远不是一个好主意。比如， new function 对构造新对象没有提供什么优势。
myObj = new function () {this.type = ‘core';};
// 更好的方式是使用对象字面量，它更轻巧，更快捷。
myObj = {type: ‘core'};

// 假如我们需要创建的对象包含的方法需要访问私有变量或者函数，更好的方式仍然是避免使用new
var foo = new function(){
	function processMessages(message){alert("Message: " + message.content);}
	this.init = function(){
		subscribe("/mytopic", this, processMessages);
	}
}
// 通过使用new去调用函数，对象会持有一个无意义的原型对象，这只会浪费内存而不会带来任何好处
// 如果不使用new，就不用在对象链中维护一个无用的prototype对象。可以用()来正确调用工厂函数
// ps:工厂模式没有解决对象的识别问题。也就是说创造的对象没办法通过instanceof方法判断它属于那个类
var foo = function(){
	function processMessages(message) {alert(”Message: ” + message.content);}
	return {init: function(){
			subscribe(”/mytopic”, this, processMessages);
		}	
	};
}();
// 原则很简单： 唯一应该要用到new操作符的地方就是调用一个古老的构造器函数的时候。
</code></pre>

<h4>十二、void</h4>
<p>在很多语言中，void是一种类型，表示没有值。而在JavaScript中，void是一个运算符，它接受一个运算符并返回undefined。这没有什么用，并且令人非常困惑。应避免使用它。</p>

</div>