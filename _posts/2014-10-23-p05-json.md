---
layout:    default
title:     JavaScript语言精粹笔记之JSON
category:  JavaScript
tags:      JavaScript语言精粹
keyword:   JavaScript语言精粹,JavaScript学习
description:  JavaScript语言精粹笔记 —— JSON。
---

<div class="post-con">
<h1>JavaScript语言精粹笔记之JSON</h1>

<h4>一、JSON简介</h4>
<p>JavaScript 对象表示法(JavaScript Object Notation，简称JSON) 是一种轻量级的数据交换格式。尽管是JavaScript的一个子集，但它与语言无关。所有以现代编程语言编写的程序，都可以用它来彼此交换数据。它是一种文本格式，所以可以被人和机器阅读。<a href="http://www.JSON.org">更多关于JSON的资料</a></p>

<h4>二、JSON语法</h4>
<p>JSON 有6种类型的值：对象、数组、字符串、数字、布尔值（true和false）和特殊值null。空白（空格符、制表符、回车符和换行符）可被插到任何值的前后。</p>
<p>1. JSON 对象 是一个容纳“名/值”对的无序集合。</p>
<p>
	1.1 名字可以是任何字符串<br>
	1.2 值可以是任何类型的JSON值，包括数组和对象<br>
	1.3 JSON对象可以被无限层地嵌套<br>
	ps: 大多数语言都容易映射为 JSON 对象的数据类型，比如对象(object)、结构(struct)、字典(dictionary)、哈希表(hash table)、属性列表(property list)或关联数组(associative array)。
</p>
<p>2. JSON 数组是一个值的有序序列。</p>
<p>
	2.1 其值可以是任何类型的JSON值，包括数组和对象
	ps：大多数语言都有容易被映射为JSON 数组的数据类型，比如数组(array)、向量(vector)、列表(list)或序列(sequence)。
</p>
<pre><code class="javascript">
[
	{
		"first": "Jerome",
		"middle": "Lester",
		"last": "Howard",
		"nick-name": "Curly",
		"born": 1903,
		"died": 1952,
		"quote": "nyuk-nyuk-nyuk!"
	},
	{
		"first": "Harry",
		"middle": "Moses",
		"last": "Howard",
		"nick-name": "Moe",
		"born": 1897,
		"died": 1975,
		"quote": "Why, you!"
	},
	{
		"first": "Louis",
		"last": "Feinberg",
		"nick-name": "Larry",
		"born": 1902,
		"died": 1975,
		"quote": "I'm sorry. Moe, it was an accident!"
	}
]
</code></pre>

<h4>三、安全地使用JSON</h4>
<p>使用eval 函数可以把一段JSON文本转化成一个有用的数据结构：</p>
<pre><code class="javascript">
var myData = eval('(' + myJSONText + ')');
// 用圆括号把JSON 文本括起来是一种避免JavaScript语法歧义的变通方案。
// 在JavaScript 的语法中，表达式语句不允许以左花括号"{"开始，因为那会与块语句产生混淆。
</code></pre>

<p>然后，eval函数存在安全问题。</p>
<p>通过使用JSON.parse 方法替代 eval 就能避免这种危险。</p>
<p>ps: 外部数据域innerHTML进行交互时还存在一种危险。一种常见的Ajax模式是把服务器端发过来的一个HTML 文本片段赋值给某个HTML元素的innerHTML 属性。如果这个HTML包含一个&lt;script&gt;标签或等价物，那么一个恶意脚本（服务器存在漏洞）将被执行。</p>

<h4>四、json解析器</h4>
<pre><code class="javascript">
var json_parse = function () {
// 这是一个能把 JSON 文本解析成 JavaScript 数据结构的函数
// 它是一个简单的递归降序解析器

// 我们在另一个函数中定义此函数，以避免创建全局变量。

	var at,      // 当前字符的索引
		ch,      // 当前字符
		escapee = {
		'"':   '"',
		'\\':  '\\',
		'/':   '/',
		b:     'b',
		f:     '\f',
		n:     '\n',
		r:     '\r',
		t:     '\t'
	},
	text,

	error = function (m) {
		// 当某处出错时调用error
		throw {
                name:    'SyntaxError',
                message: m,
                at:      at,
                text:    text
            };
	},

	next = function (c) {
		// 如果提供了参数c，那么检查它是否匹配当前字符。
		if (c && c !== ch){
			error("Expected '" + c + "' instead of '" + ch + "'");
		}
		// 获取下一个字符。当没有下一个字符时，返回一个空字符串。
		ch = text.charAt(at);
		at += 1;
		return ch; 
	},

	number = function () {
		// 解析一个数字值
		var number,
		    string = '';

		if (ch === '-') {
			string = '-';
			next('-');
		}
		while (ch >= '0' && ch <= '9') {
			string += ch;
			next();
		}
		if (ch === '.') {
			string += '.';
			while (next() && ch >= '0' && ch<= '9') {
				string += ch;
			}
		}
		if (ch === 'e' || ch === 'E') {
			string += ch;
			next();
			if (ch ==='-' || ch === '+') {
				string += ch;
				next();
			}
			while (ch >= '0' && ch <= '9') {
				string += ch;
				next();
			}
		}
		number = +string;
		if (isNaN(number)) {
			error("Bad number");
		} else {
			return number;
		}		
	},

	string = function() {
		// 解析一个字符串值
		var hex,
		    i,
		    string = '',
		    uffff;
		// 当解析字符串值时，我们必须找到 " 和 \ 字符。
		if (ch === '"'){
			while (next()){
				if (ch === '"') {
					next();
					return string;
				}else if (ch === '\\') {
					next();
					if (ch === 'u') {
						uffff = 0;
						for (i = 0; i < 4 ;i += 1) {
							hex = parseInt (next(), 16);
							if (!isFinite(hex)) {
								break;
							}
							uffff = uffff * 16 + hex;
						}
						string += String.fromCharCode(uffff);
					} else if (typeof escapee[ch] === 'string') {
						string += escapee[ch];
					} else {
						break;
					}
				} else {
					string += ch;
				}
			}
		}
		error("Bad string");
	},

	white = function () {
		// 跳过空白。
		while (ch && ch <= ' ') {
			next();
		}
	},

	word = function() {
		// true、false 或null。
		switch (ch) {
			case 't':
				next('t');
				next('r');
				next('u');
				next('e');
				return true;
			case 'f':
				next('f');
				next('a');
				next('l');
				next('s');
				next('e');
				return false;
			case 'n':
				next('n');
				next('u');
				next('l');
				next('l');
				return null;
		}
		error("Unexpected '" + ch + "'");
	},

	value, // 值函数的占位符

	array = function () {
		// 解析一个数组值
		var array = [];
		 if (ch === '[') {
            next('[');
            white();
            if (ch === ']') {
                next(']');
                return array;     // 空数组
            }
			while (ch) {
                array.push(value());
                white();
                if (ch === ']') {
                	next(']');
                	return array;
                }
                next(',');
                white();
            }
		}
		error("Bad array");
	},

	object = function () {
		// 解析一个对象值
		var key,
		    object = {};

		if (ch === '{') {
			next('{');
			white();
			if (ch === '}'){
				return object;  // 空对象
			}
			while (ch) {
				key = string();
				white();
				next(':');
				object[key] = value();
				white();
				if (ch === '}') {
					next('}');
					return object;
				}
				next(',');
				white();
			}
		}
		error("Bad object");
	};

	value = function() {
		// 解析一个JSON值。它可以是对象、数组、字符串、数字或一个词。
		white();
		switch (ch) {
			case '{':
				return object();
			case '[':
				return array();
			case '"':
				return string();
			case '-':
				return number();
			default:
				return ch >= '0' && ch <= '9' ? number() : word();
		}
	};

	// 返回json_parse函数。它能访问上述所有函数和变量。

	return function (source, reviver) {
		var result;

		text = source;
		at = 0;
		ch = ' ';
		result = value();
		white();
		if (ch) {
			error('Syntax error');
		}	

		// 如果存在reviver函数，我们就递归地对这个新结构调用 walk 函数，
		// 开始时先创建一个临时的启动对象，并以一个空字符串作为键名保存结果，
		// 然后传递每个 "名/值" 对给 reviver 函数去处理可能存在的转换。
		// 如果没有 reviver 函数，我们就简单地返回这个结果
		
		return typeof reviver === 'function' ?
			function walk(holder, key) {
			var k, v, value = holder[key];
			if (value && typeof value === 'object') {
				for (k in value) {
					if (Object.hasOwnProperty.call(value, k)) {
						v = walk(value, k);
						if (v !== underfined) {
							value[k] = v;
						} else {
							delete value[k];
						}
					}
				}
			}
			return reviver.call(holder, key, value);	
		}({'': result}, '') : result;

	};
}();
</code></pre>



</div>